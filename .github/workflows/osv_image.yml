name: Scan container image with OSV-Scanner
on:
  workflow_call:
    inputs:
      containerfile:
        description: |
          Path to the Containerfile. The image will be built and then scanned.
          The image name is derived from the directory containing the Containerfile.
          If the Containerfile is in the root, the repository name is used.
        required: true
        type: string
      image-tag:
        description: 'Tag for the built image.'
        required: false
        type: string
        default: 'test'
      fail-on-severity:
        description: 'The minimum severity to fail the scan on. Can be one of: critical, high, medium, low.'
        required: false
        type: string
        default: 'high'
permissions:
  contents: read # packages:write is no longer needed
jobs:
  build-and-scan:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6

      - name: Derive image name and context path
        id: paths
        run: |
          set -e
          CONTAINERFILE_PATH="${{ inputs.containerfile }}"
          CONTEXT_DIR=$(dirname "$CONTAINERFILE_PATH")
          if [ "$CONTEXT_DIR" = "." ]; then
            IMAGE_NAME=$(echo "${{ github.repository }}" | cut -d'/' -f2)
          else
            IMAGE_NAME=$(basename "$CONTEXT_DIR")
          fi
          echo "context_dir=${CONTEXT_DIR}" >> "$GITHUB_OUTPUT"
          echo "image_name=${IMAGE_NAME}" >> "$GITHUB_OUTPUT"
        shell: bash

      - name: Cache Docker layers
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache
          # Invalidate cache if the Dockerfile changes
          key: ${{ runner.os }}-buildx-${{ hashFiles(inputs.containerfile) }}
          restore-keys: |
            ${{ runner.os }}-buildx-

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image for scanning
        uses: docker/build-push-action@263435318d21b8e681c14492fe198d362a7d2c83 # v6
        with:
          context: ${{ steps.paths.outputs.context_dir }}
          file: ${{ inputs.containerfile }}
          tags: ${{ steps.paths.outputs.image_name }}:${{ inputs.image-tag }}
          push: false
          load: true
          # Use local caching
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache-new,mode=max

      - name: Move cache
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache

      - uses: actions/setup-go@v6
        with:
          go-version: '1.25.4'

      - name: Cache osv-scanner
        id: cache-osv-scanner
        uses: actions/cache@v4
        with:
          path: ~/go/bin
          key: ${{ runner.os }}-go-osv-scanner-go1.25.4
          restore-keys: |
            ${{ runner.os }}-go-osv-scanner-

      - name: Install osv-scanner
        if: steps.cache-osv-scanner.outputs.cache-hit != 'true'
        run: go install github.com/google/osv-scanner/v2/cmd/osv-scanner@v2.3.0

      - name: Scan built image with OSV-Scanner
        run: |
          set -e
          SCAN_OUTPUT_FILE="osv-scan-results.txt"
          osv-scanner scan image "${{ steps.paths.outputs.image_name }}:${{ inputs.image-tag }}" > "$SCAN_OUTPUT_FILE" || true
          cat "$SCAN_OUTPUT_FILE"

          SUMMARY_LINE=$(grep 'Total .* packages affected by' "$SCAN_OUTPUT_FILE")

          if [ -z "$SUMMARY_LINE" ]; then
            echo "Could not find summary line in OSV scanner output. Assuming no vulnerabilities."
            exit 0
          fi

          get_count() {
            local severity=$1
            local line=$2
            local count=$(echo "$line" | grep -o "[0-9]* $severity" | awk '{print $1}')
            echo "${count:-0}"
          }

          CRITICAL_COUNT=$(get_count "Critical" "$SUMMARY_LINE")
          HIGH_COUNT=$(get_count "High" "$SUMMARY_LINE")
          MEDIUM_COUNT=$(get_count "Medium" "$SUMMARY_LINE")
          LOW_COUNT=$(get_count "Low" "$SUMMARY_LINE")

          echo "Vulnerability counts:"
          echo "Critical: $CRITICAL_COUNT"
          echo "High: $HIGH_COUNT"
          echo "Medium: $MEDIUM_COUNT"
          echo "Low: $LOW_COUNT"

          FAIL_SEVERITY="${{ inputs.fail-on-severity }}"
          FAIL=0

          echo "Checking for vulnerabilities with severity >= ${FAIL_SEVERITY}"

          if [[ "$FAIL_SEVERITY" == "low" ]]; then
            if (( CRITICAL_COUNT > 0 || HIGH_COUNT > 0 || MEDIUM_COUNT > 0 || LOW_COUNT > 0 )); then
              FAIL=1
            fi
          elif [[ "$FAIL_SEVERITY" == "medium" ]]; then
            if (( CRITICAL_COUNT > 0 || HIGH_COUNT > 0 || MEDIUM_COUNT > 0 )); then
              FAIL=1
            fi
          elif [[ "$FAIL_SEVERITY" == "high" ]]; then
            if (( CRITICAL_COUNT > 0 || HIGH_COUNT > 0 )); then
              FAIL=1
            fi
          elif [[ "$FAIL_SEVERITY" == "critical" ]]; then
            if (( CRITICAL_COUNT > 0 )); then
              FAIL=1
            fi
          fi

          if [[ "$FAIL" -eq 1 ]]; then
            echo "Failing because vulnerabilities were found with severity >= ${FAIL_SEVERITY}"
            exit 1
          else
            echo "No vulnerabilities found with severity >= ${FAIL_SEVERITY}"
            exit 0
          fi
        shell: bash
